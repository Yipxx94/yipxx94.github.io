[{"categories":["算法"],"content":"总结了三种在算法中最常用的递归模型","date":"2022-05-27","objectID":"/recur/","tags":["C++"],"title":"关于常见的三种递归模型","uri":"/recur/"},{"categories":["算法"],"content":"1. 递归实现指数型枚举 78. 子集 每个数有两种情况，选或不选，总方案数为$2^n$。 ","date":"2022-05-27","objectID":"/recur/:1:0","tags":["C++"],"title":"关于常见的三种递归模型","uri":"/recur/"},{"categories":["算法"],"content":"代码 class Solution { public: int n; vector\u003cint\u003e path; vector\u003cvector\u003cint\u003e\u003e res; vector\u003cvector\u003cint\u003e\u003e subsets(vector\u003cint\u003e\u0026 nums) { n = nums.size(); dfs(nums, 0); return res; } void dfs(vector\u003cint\u003e\u0026 nums, int u) { if (u == n) { res.push_back(path); return; } // 不选当前数 dfs(nums, u + 1); // 选当前数 path.push_back(nums[u]); dfs(nums, u + 1); path.pop_back(); // 回溯 } }; ","date":"2022-05-27","objectID":"/recur/:1:1","tags":["C++"],"title":"关于常见的三种递归模型","uri":"/recur/"},{"categories":["算法"],"content":"2. 递归实现排列型枚举 46. 全排列 ","date":"2022-05-27","objectID":"/recur/:2:0","tags":["C++"],"title":"关于常见的三种递归模型","uri":"/recur/"},{"categories":["算法"],"content":"代码 class Solution { public: int n; vector\u003cint\u003e nums; vector\u003cint\u003e path; vector\u003cbool\u003e st; vector\u003cvector\u003cint\u003e\u003e res; vector\u003cvector\u003cint\u003e\u003e permute(vector\u003cint\u003e\u0026 _nums) { nums = _nums; n = nums.size(); st.resize(n); dfs(0); return res; } void dfs(int u) { if (u == n) { res.push_back(path); return; } for (int i = 0; i \u003c n; i ++ ) { if (!st[i]) // 如果当前数没使用过 { st[i] = true; path.push_back(nums[i]); dfs(u + 1); path.pop_back(); st[i] = false; } } } }; ","date":"2022-05-27","objectID":"/recur/:2:1","tags":["C++"],"title":"关于常见的三种递归模型","uri":"/recur/"},{"categories":["算法"],"content":"3. 递归实现组合型枚举 77. 组合 从$n$个数里选$m$个数，且含有相同数字的集合视为同一个集合。 ","date":"2022-05-27","objectID":"/recur/:3:0","tags":["C++"],"title":"关于常见的三种递归模型","uri":"/recur/"},{"categories":["算法"],"content":"代码 class Solution { public: int n, k; vector\u003cint\u003e path; vector\u003cvector\u003cint\u003e\u003e res; vector\u003cvector\u003cint\u003e\u003e combine(int _n, int _k) { n = _n, k = _k; dfs(1, 1); return res; } void dfs(int u, int idx) { if (n + u - idx \u003c k) return; // 剪枝，当把后面的数全选上也不够k个时，直接退出 if (u \u003e k) { res.push_back(path); return; } for (int i = idx; i \u003c= n; i ++ ) { path.push_back(i); dfs(u + 1, i + 1); path.pop_back(); } } }; ","date":"2022-05-27","objectID":"/recur/:3:1","tags":["C++"],"title":"关于常见的三种递归模型","uri":"/recur/"},{"categories":["算法"],"content":"二叉树迭代法遍历的模板","date":"2022-05-16","objectID":"/tree/","tags":["C++"],"title":"迭代法实现二叉树的前序、中序和后续遍历","uri":"/tree/"},{"categories":["算法"],"content":"本文的目的是为了总结出一个通用的，改动较少的非递归模板，可以分别适用于二叉树的前序、中序和后续遍历，方便记忆。 ","date":"2022-05-16","objectID":"/tree/:1:0","tags":["C++"],"title":"迭代法实现二叉树的前序、中序和后续遍历","uri":"/tree/"},{"categories":["算法"],"content":"前序遍历 前序遍历的遍历顺序为：根 -\u003e 左 -\u003e 右。 只要有左子树，就把左子树入栈，同时把值加入答案数组，然后依次弹出栈顶元素，移动到它的右子树，重复操作。 class Solution { public: vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e res; stack\u003cTreeNode*\u003e stk; while (root || stk.size()) { while (root) { res.push_back(root-\u003eval); stk.push(root); root = root-\u003eleft; } root = stk.top(); stk.pop(); root = root-\u003eright; } return res; } }; ","date":"2022-05-16","objectID":"/tree/:1:1","tags":["C++"],"title":"迭代法实现二叉树的前序、中序和后续遍历","uri":"/tree/"},{"categories":["算法"],"content":"中序遍历 中序遍历的遍历顺序为：左 -\u003e 右 -\u003e 根。 只要有左子树，就把左子树入栈，然后依次弹出栈顶元素，弹出的同时时把值加入答案数组，移动到它的右子树，重复操作。 class Solution { public: vector\u003cint\u003e inorderTraversal(TreeNode* root) { vector\u003cint\u003e res; stack\u003cTreeNode*\u003e stk; while (root || stk.size()) { while (root) { // res.push_back(root-\u003eval); 与前序遍历不一样的地方 stk.push(root); root = root-\u003eleft; } root = stk.top(); stk.pop(); res.push_back(root-\u003eval); // 与前序遍历唯一不同的地方 root = root-\u003eright; } return res; } }; ","date":"2022-05-16","objectID":"/tree/:1:2","tags":["C++"],"title":"迭代法实现二叉树的前序、中序和后续遍历","uri":"/tree/"},{"categories":["算法"],"content":"后序遍历 后序遍历的遍历顺序为：左 -\u003e 右 -\u003e 根。 已知前序遍历的遍历顺序为：根 -\u003e 左 -\u003e 右，我们可以将后续遍历的顺序反过来，变成根 -\u003e 右 -\u003e 左，这样的话遍历的方法只需在前序遍历的基础上改动一下即可。 只要有右子树，就把右子树入栈，同时把值加入答案数组，然后依次弹出栈顶元素，移动到它的左子树，重复操作。 最后，翻转一下答案数组即可。 class Solution { public: vector\u003cint\u003e postorderTraversal(TreeNode* root) { vector\u003cint\u003e res; stack\u003cTreeNode*\u003e stk; while (root || stk.size()) { while (root) { res.push_back(root-\u003eval); stk.push(root); root = root-\u003eright; // root = root-\u003eleft 与前序遍历不一样的地方 } root = stk.top(); stk.pop(); root = root-\u003eleft; // root = root-\u003eright 与前序遍历不一样的地方 } reverse(res.begin(), res.end()); // 翻转答案数组 return res; } }; ","date":"2022-05-16","objectID":"/tree/:1:3","tags":["C++"],"title":"迭代法实现二叉树的前序、中序和后续遍历","uri":"/tree/"},{"categories":["Python语法"],"content":"介绍项目开发中Python虚拟环境的创建和使用","date":"2022-03-14","objectID":"/python_venv/","tags":["Python"],"title":"Python的venv虚拟环境和pip包","uri":"/python_venv/"},{"categories":["Python语法"],"content":"前言 Python应用程序通常会使用不在标准库内的软件包和模块。应用程序有时需要特定版本的库，因为应用程序可能需要修复特定的错误，或者可以使用库的过时版本的接口编写应用程序。 这意味着一个Python安装可能无法满足每个应用程序的要求。如果应用程序 A 需要特定模块的 1.0 版本但应用程序B需要 2.0 版本，则需求存在冲突，安装版本 1.0 或 2.0 将导致某一个应用程序无法运行。 这个问题的解决方案是创建一个virtual environment，一个目录树，其中安装有特定Python版本，以及许多其他包。 然后，不同的应用将可以使用不同的虚拟环境。 要解决先前需求相冲突的例子，应用程序 A 可以拥有自己的 安装了 1.0 版本的虚拟环境，而应用程序 B 则拥有安装了 2.0 版本的另一个虚拟环境。 如果应用程序 B 要求将某个库升级到 3.0 版本，也不会影响应用程序 A 的环境。 信息 virtual environment – 虚拟环境 一种采用协作式隔离的运行时环境，允许 Python 用户和应用程序在安装和升级 Python 分发包时不会干扰到同一系统上运行的其他 Python 应用程序的行为。 ","date":"2022-03-14","objectID":"/python_venv/:1:0","tags":["Python"],"title":"Python的venv虚拟环境和pip包","uri":"/python_venv/"},{"categories":["Python语法"],"content":"创建虚拟环境 用于创建和管理虚拟环境的模块称为venv。venv通常会安装你可用的最新版本的Python。如果您的系统上有多个版本的Python，可以通过运行python3或其他的任何版本来选择特定的Python版本。 注意：以下的命令均为linux下的命令。 安装venv sudo apt-get install python3.8-venv 进入你需要的目录下，创建tutorial-env虚拟环境目录 python3 -m venv 名称（如tutorial-env） 激活虚拟环境 source tutorial-env/bin/activate 退出虚拟环境 deactivate 注意 激活虚拟环境将改变你所用终端的提示符，以显示你正在使用的虚拟环境，并修改环境以使 python 命令所运行的将是已安装的特定 Python 版本。 例如： $ source ~/envs/tutorial-env/bin/activate (tutorial-env) $ python ","date":"2022-03-14","objectID":"/python_venv/:2:0","tags":["Python"],"title":"Python的venv虚拟环境和pip包","uri":"/python_venv/"},{"categories":["Python语法"],"content":"使用pip管理包 可以使用一个名为pip的程序来安装、升级和移除软件包。pip有许多子命令: install, uninstall, freeze等。 可以通过指定包的名称来安装最新版本的包： python -m pip install novas 可以通过提供包名称后跟==和版本号来安装特定版本的包： python -m pip install Django==3.2.8 其他常用命令 pip install --upgrade 将软件包升级到最新版本 pip uninstall 后跟一个或多个包名称将从虚拟环境中删除包 pip show 将显示有关特定包的信息 pip list 将显示虚拟环境中安装的所有软件包 pip freeze 将生成一个类似的已安装包列表，但输出使用pip install期望的格式 ","date":"2022-03-14","objectID":"/python_venv/:3:0","tags":["Python"],"title":"Python的venv虚拟环境和pip包","uri":"/python_venv/"},{"categories":["Go语法"],"content":"解决go的切片作为函数参数在函数传递过程中的问题","date":"2022-03-03","objectID":"/go_slice/","tags":["golang"],"title":"Go的切片在函数传递中的用法","uri":"/go_slice/"},{"categories":["Go语法"],"content":"前言 在力扣刷题的过程中，如果像使用C++的引用一样来使用go的切片来进行递归，有时候会出现问题。下面我来详细的解释一下。 ","date":"2022-03-03","objectID":"/go_slice/:1:0","tags":["golang"],"title":"Go的切片在函数传递中的用法","uri":"/go_slice/"},{"categories":["Go语法"],"content":"Slice——切片 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。 切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。 ","date":"2022-03-03","objectID":"/go_slice/:2:0","tags":["golang"],"title":"Go的切片在函数传递中的用法","uri":"/go_slice/"},{"categories":["Go语法"],"content":"定义 var name []T name：表示变量名 T：表示切片中的元素类型，如，int ","date":"2022-03-03","objectID":"/go_slice/:2:1","tags":["golang"],"title":"Go的切片在函数传递中的用法","uri":"/go_slice/"},{"categories":["Go语法"],"content":"切片的长度和容量 切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。 ","date":"2022-03-03","objectID":"/go_slice/:2:2","tags":["golang"],"title":"Go的切片在函数传递中的用法","uri":"/go_slice/"},{"categories":["Go语法"],"content":"切片表达式 切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。 简单切片表达式 切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的low和high表示一个索引范围（左闭右开），得到的切片长度=high-low，容量等于得到的切片的底层数组的容量。 如： func main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high] fmt.Printf(\"s:%v len(s):%v cap(s):%v\\n\", s, len(s), cap(s)) } 输出： s:[2 3] len(s):2 cap(s):4 可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度: a[2:] // 等同于 a[2:len(a)] a[:3] // 等同于 a[0:3] a[:] // 等同于 a[0:len(a)] 注意 对于数组或字符串，如果0 \u003c= low \u003c= high \u003c= len(a)，则索引合法，否则就会索引越界（out of range）。 完整切片表达式 对于数组，指向数组的指针，或切片a（注意不能是字符串）支持完整切片表达式。 a[low:high:max] 上述代码会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。 如： func main() { a := [5]int{1, 2, 3, 4, 5} t := a[1:3:5] fmt.Printf(\"t:%v len(t):%v cap(t):%v\\n\", t, len(t), cap(t)) } 输出： t:[2 3] len(t):2 cap(t):4 完整切片表达式需要满足的条件是0 \u003c= low \u003c= high \u003c= cap(a) \u003c= max，其他条件和简单切片表达式相同。 ","date":"2022-03-03","objectID":"/go_slice/:2:3","tags":["golang"],"title":"Go的切片在函数传递中的用法","uri":"/go_slice/"},{"categories":["Go语法"],"content":"append()函数为切片添加元素 Go语言的内置函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素。 func main(){ var s []int s = append(s, 1) // [1] s = append(s, 2, 3, 4) // [1 2 3 4] s2 := []int{5, 6, 7} s = append(s, s2...) // [1 2 3 4 5 6 7] } 通过var声明的零值切片可以在append()函数直接使用，无需初始化。 信息 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。 如： func main() { //append()添加元素和切片扩容 var numSlice []int for i := 0; i \u003c 10; i++ { numSlice = append(numSlice, i) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", numSlice, len(numSlice), cap(numSlice), numSlice) } } 输出： [0] len:1 cap:1 ptr:0xc0000a8000 [0 1] len:2 cap:2 ptr:0xc0000a8040 [0 1 2] len:3 cap:4 ptr:0xc0000b2020 [0 1 2 3] len:4 cap:4 ptr:0xc0000b2020 [0 1 2 3 4] len:5 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5] len:6 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6] len:7 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6 7] len:8 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6 7 8] len:9 cap:16 ptr:0xc0000b8000 [0 1 2 3 4 5 6 7 8 9] len:10 cap:16 ptr:0xc0000b800 可以看出： append()函数将元素追加到切片的最后并返回该切片。 切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。 ","date":"2022-03-03","objectID":"/go_slice/:3:0","tags":["golang"],"title":"Go的切片在函数传递中的用法","uri":"/go_slice/"},{"categories":["Go语法"],"content":"作为函数参数的切片 示例1： func main(){ slice:=[]int{1,2,3} fmt.Printf(\"slice %v,slice address %p\\n\",slice,\u0026slice) slice=changeSlice(slice) fmt.Printf(\"slice %v,slice address %p\",slice,\u0026slice) } func changeSlice(nums []int)[]int{ nums[1]=111 return nums } 输出： slice [1 2 3],slice address 0xc0420023e0 slice [1 111 3],slice address 0xc0420023e0 由示例1可以看出，外部切片中的值进行了改变，地址没有进行改变。 示例2： func main(){ slice:=[]int{1,2,3} fmt.Printf(\"slice %v,slice address %p\\n\",slice,\u0026slice) slice=changeSlice(slice) fmt.Printf(\"slice %v,slice address %p\\n\",slice,\u0026slice) } func changeSlice(nums []int)[]int{ fmt.Printf(\"nums: %v,nums addr: %p\\n\",nums,\u0026nums) nums[1]=111 return nums } 输出： slice [1 2 3],slice address 0xc04204a3a0 nums: [1 2 3],nums addr: 0xc04204a400 slice [1 111 3],slice address 0xc04204a3a0 由示例2可以看出，我们在函数中打印了传入函数的切片地址，发现和外部切片地址并不一样。 当函数的参数是切片的时候，到底是传值还是传引用？从changeSlice函数中打出的参数s的地址，可以看出肯定不是传引用，毕竟引用都是一个地址才对。然而changeSlice函数内改变了s的值，也改变了原始变量slice的值，这个看起来像引用的现象，实际上正是我们前面讨论的切片共享底层数组的实现。 即切片传递的时候，传的是数组的值，等效于从原始切片中再切了一次。原始切片slice和参数s切片的底层数组是一样的。因此修改函数内的切片，也就修改了数组。 信息 当使用append()函数时，如果切片的容量不够，就会新生成一个底层数组，所以内存地址改变，并且改变新切片对原来的没有任何影响。 ","date":"2022-03-03","objectID":"/go_slice/:3:1","tags":["golang"],"title":"Go的切片在函数传递中的用法","uri":"/go_slice/"},{"categories":["Hugo系列"],"content":"博客功能增强与美化（持续更新中...）","date":"2022-01-27","objectID":"/hugo_conf2/","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"前言 Hugo本身可以通过修改站点配置文件来完成页面的部分定制，如按钮、多语言等功能。本博客使用的是Hugo的LoveIt主题，本文也是基于该主题而写的，不过Hugo的美化步骤应该大同小异。 ","date":"2022-01-27","objectID":"/hugo_conf2/:1:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"添加全局的CDN变量 对于一些静态资源，比如图片、音乐文件、第三方库等，如果有自己的cdn或者图床等，可以在站点配置文件自定义一个cdn变量，如下： [params] # cdn变量，末尾不需要加/ cdnPrefix = \"http://xxxx\" 默认的 CDN 数据文件位于themes/LoveIt/assets/data/cdn/目录，可以在你的项目下相同路径存放你自己的数据文件：assets/data/cdn/。接下来就可以在你需要的地方使用该变量，大概有如下3种用法。 ","date":"2022-01-27","objectID":"/hugo_conf2/:2:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"在md文件中使用 在md文件中可以用内置的shortcodes来使用该变量： {{\u003c param cdnPrefix \u003e}} ![avatar.jpg]({{\u003c param cdnPrefix \u003e}}/images/avatar.jpg) ","date":"2022-01-27","objectID":"/hugo_conf2/:2:1","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"在模板文件中使用 在layouts目录下有很多html文件，这些是用来渲染站点的模板文件，可以用Hugo的语法来引入该变量： {{ .Site.Params.cdnPrefix }} 如果在一个模板文件里有多个地方使用到该变量，可以定义一个局部变量来使用： {{- $cdn := .Site.Params.cdnPrefix -}} /* 使用局部变量 */ {{ $cdn }} ","date":"2022-01-27","objectID":"/hugo_conf2/:2:2","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"在JavaScript文件中使用 由于JavaScript文件中不能使用上述的shortcodes或Hugo语法来引用变量，只能通过在\\layouts\\partials\\assets.html中用JavaScript语法来引入该变量，如下： /* 这是可以应用于JavaScript文件的全局变量 */ \u003cscript\u003e /* cdn for some static resources */ var $cdnPrefix = {{ .Site.Params.cdnPrefix }}; \u003c/script\u003e 这样就可以在其他被引入的JavaScript文件中使用这个$cdnPrefix变量： $(function () { $.backstretch([ $cdnPrefix + \"/images/background/saber1.jpg\" ], { duration: 60000, fade: 1500 }); }); 如果是想在模板文件里引入某个自定义的JavaScript文件，如下： {{- /* 自定义的js文件 */ -}} \u003cscript type=\"text/javascript\" src=\"{{ .Site.Params.cdnPrefix }}/js/custom.js\"\u003e\u003c/script\u003e ","date":"2022-01-27","objectID":"/hugo_conf2/:2:3","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"Valine评论功能添加 把\\themes\\LoveIt\\layouts\\partials\\comment.html拷贝到站点根目录下的\\layouts\\partials\\comment.html。 打开拷贝后的comment.html，找到Valine相关的代码，把{{- if $valine.enable -}}和{{- end -}}之间的代码改成如下： {{- if $valine.enable -}} \u003cdiv id=\"valine\" class=\"comment\"\u003e\u003c/div\u003e \u003cscript src=\"//unpkg.com/valine@latest/dist/Valine.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e new Valine({ el: '#valine' , appId: '{{ $valine.appId }}', appKey: '{{ $valine.appKey }}', notify: '{{ $valine.notify }}', verify: '{{ $valine.verify }}', avatar:'{{ $valine.avatar }}', placeholder: '{{ $valine.placeholder }}', visitor: '{{ $valine.visitor }}' }); \u003c/script\u003e {{- end -}} 之后在站点配置文件里启用valine，然后填上从LeanCloud的应用中得到的appId和appKey就可以用了。并且在使用了valine的同时，还可以顺带启用阅读次数的统计功能。 ","date":"2022-01-27","objectID":"/hugo_conf2/:3:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"LeanCloud的使用 在LeanCloud官网注册账号； 创建一个应用，然后进入该应用的配置，选择设置 -\u003e 应用凭证，然后复制该应用的AppId和AppKey到站点配置文件里; 选择设置 -\u003e 安全中心，在Web安全域名中输入站点域名，或http://localhost:1313； 选择数据存储 -\u003e 结构化数据，创建两个新的Class，Comment（评论会存在这里）和Counter（阅读次数统计）。 ","date":"2022-01-27","objectID":"/hugo_conf2/:3:1","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"添加站点运行时间 将\\themes\\LoveIt\\layouts\\partials\\footer.html拷贝到\\layouts\\partials\\footer.html，打开拷贝后的文件，在\u003cdiv class=\"footer-container\"\u003e的下方添加如下代码： \u003cdiv class=\"footer-line\"\u003e \u003cspan id=\"run-time\"\u003e\u003c/span\u003e \u003c/div\u003e 然后在custom.js中添加如下代码： /* 站点运行时间 */ function runtime() { window.setTimeout(\"runtime()\", 1000); /* 请修改这里的起始时间 */ let startTime = new Date('12/10/2021 21:00:00'); let endTime = new Date(); let usedTime = endTime - startTime; let days = Math.floor(usedTime / (24 * 3600 * 1000)); let leavel = usedTime % (24 * 3600 * 1000); let hours = Math.floor(leavel / (3600 * 1000)); let leavel2 = leavel % (3600 * 1000); let minutes = Math.floor(leavel2 / (60 * 1000)); let leavel3 = leavel2 % (60 * 1000); let seconds = Math.floor(leavel3 / (1000)); let runbox = document.getElementById('run-time'); runbox.innerHTML = '本站已运行\u003ci class=\"far fa-clock fa-fw\"\u003e\u003c/i\u003e ' + ((days \u003c 10) ? '0' : '') + days + ' 天 ' + ((hours \u003c 10) ? '0' : '') + hours + ' 时 ' + ((minutes \u003c 10) ? '0' : '') + minutes + ' 分 ' + ((seconds \u003c 10) ? '0' : '') + seconds + ' 秒 '; } runtime(); ","date":"2022-01-27","objectID":"/hugo_conf2/:4:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"添加不蒜子网站计数 在根目录的config.toml文件中加入如下代码： [params] ... # 以下为需添加内容 # # busuanzi busuanzi = true busuanzi_site_offset = 100000 打开\\layouts\\partials\\footer.html，添加如下代码： {{- if ne .Site.Params.footer.enable false -}} \u003cfooter class=\"footer\"\u003e \u003cdiv class=\"footer-container\"\u003e ... \u003c!-- 以下为需添加内容 --\u003e \u003cscript async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"\u003e \u003c/script\u003e \u003cspan id=\"busuanzi_container_site_pv\"\u003e 本站访问量：\u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e次 \u003c/span\u003e | \u003cspan id=\"busuanzi_container_site_uv\"\u003e 您是本站第 \u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e 位访问者 \u003c/span\u003e \u003c!-- 以上为需添加内容 --\u003e \u003c/div\u003e \u003c/footer\u003e {{- end -}} 如果需要更多的网站统计功能，可参考不蒜子博客。 ","date":"2022-01-27","objectID":"/hugo_conf2/:5:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"主题自带的admonition样式 LoveIt提供了admonitionshortcode，支持12种样式，可以在页面中插入提示的横幅。代码如下： {{\u003c admonition \u003e}} 一个 **注意** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition abstract \u003e}} 一个 **摘要** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition info \u003e}} 一个 **信息** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition tip \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition success \u003e}} 一个 **成功** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition question \u003e}} 一个 **问题** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition warning \u003e}} 一个 **警告** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition failure \u003e}} 一个 **失败** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition danger \u003e}} 一个 **危险** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition bug \u003e}} 一个 **Bug** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition example \u003e}} 一个 **示例** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition quote \u003e}} 一个 **引用** 横幅 {{\u003c /admonition \u003e}} 效果如下： 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 ","date":"2022-01-27","objectID":"/hugo_conf2/:6:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"为图标添加动画效果 \u003cdiv class=\"fa-3x\"\u003e \u003ci class=\"fas fa-spinner fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fas fa-circle-notch fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fas fa-sync fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fas fa-cog fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fas fa-spinner fa-pulse\"\u003e\u003c/i\u003e \u003ci class=\"fas fa-stroopwafel fa-spin\"\u003e\u003c/i\u003e \u003c/div\u003e ","date":"2022-01-27","objectID":"/hugo_conf2/:7:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"添加文章打赏功能 ","date":"2022-01-27","objectID":"/hugo_conf2/:8:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"配置文件添加相关变量 在config.toml添加如下变量： [params.reward] # 文章打赏 enable = true wechat = \"/images/wechat.png\" # 微信二维码 alipay = \"/images/alipay.png\" # 支付宝二维码 这里是对全局文章生效，也可以在每篇文章的文件头里添加如下变量来控制是否启用该功能： reward: false ","date":"2022-01-27","objectID":"/hugo_conf2/:8:1","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"新建模板文件reward.html 新建模板文件/layouts/partials/single/reward.html，内容如下： {{ if or .Params.reward (and .Site.Params.reward.enable (ne .Params.reward false)) -}} \u003cdiv class=\"post-reward\"\u003e \u003cinput type=\"checkbox\" name=\"reward\" id=\"reward\" hidden /\u003e \u003clabel class=\"reward-button\" for=\"reward\"\u003e{{ T \"reward\" }}\u003c/label\u003e \u003cdiv class=\"qr-code\"\u003e {{ $qrCode := .Site.Params.reward }} {{- $cdnPrefix := .Site.Params.cdnPrefix -}} {{ with $qrCode.wechat -}} \u003clabel class=\"qr-code-image\" for=\"reward\"\u003e \u003cimg class=\"image\" src=\"{{ $cdnPrefix }}{{ . }}\"\u003e \u003cspan\u003e{{ T \"rewardWechat\" }}\u003c/span\u003e \u003c/label\u003e {{- end }} {{ with $qrCode.alipay -}} \u003clabel class=\"qr-code-image\" for=\"reward\"\u003e \u003cimg class=\"image\" src=\"{{ $cdnPrefix }}{{ . }}\"\u003e \u003cspan\u003e{{ T \"rewardAlipay\" }}\u003c/span\u003e \u003c/label\u003e {{- end }} \u003c/div\u003e \u003c/div\u003e {{- end }} ","date":"2022-01-27","objectID":"/hugo_conf2/:8:2","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"修改模板文件 将/themes/LoveIt/layouts/posts/single.html拷贝到/layouts/posts/single.html，打开拷贝后的文件，找到如下内容： {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e 修改成如下： {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} {{- /* Reward */ -}} {{- partial \"single/reward.html\" . -}} \u003c/div\u003e ","date":"2022-01-27","objectID":"/hugo_conf2/:8:3","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"添加CSS代码 在自定义的_custom.scss里添加如下样式： /* 打赏 */ article .post-reward { margin-top: 20px; padding-top: 10px; text-align: center; border-top: 1px dashed #e6e6e6 } article .post-reward .reward-button { margin: 15px 0; padding: 3px 7px; display: inline-block; color: #c05b4d; border: 1px solid #c05b4d; border-radius: 5px; cursor: pointer } article .post-reward .reward-button:hover { color: #fefefe; background-color: #c05b4d; transition: .5s } article .post-reward #reward:checked~.qr-code { display: block } article .post-reward #reward:checked~.reward-button { display: none } article .post-reward .qr-code { display: none } article .post-reward .qr-code .qr-code-image { display: inline-block; min-width: 200px; width: 40%; margin-top: 15px } article .post-reward .qr-code .qr-code-image span { display: inline-block; width: 100%; margin: 8px 0 } article .post-reward .qr-code .image { width: 200px; height: 200px } ","date":"2022-01-27","objectID":"/hugo_conf2/:8:4","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"菜单栏支持子菜单 ","date":"2022-01-27","objectID":"/hugo_conf2/:9:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"修改模板代码 将主题的/themes/LoveIt/layouts/partials/header.html拷贝一份到layouts/partials/header.html，找到如下代码，一共有两个地方，分别对应网页端和手机端： {{-range.Site.Menus.main-}}{{-$url:=.URL|relLangURL-}}{{-with.Page-}}{{-$url=.RelPermalink-}}{{-end-}}\u003caclass=\"menu-item{{ if $.IsMenuCurrent `main` . | or ($.HasMenuCurrent `main` .) | or (eq $.RelPermalink $url) }} active{{ end }}\"href=\"{{ $url }}\"{{with.Title}}title=\"{{ . }}\"{{end}}{{if(urls.Parse$url).Host}}rel=\"noopener noreffer\"target=\"_blank\"{{end}}\u003e{{-.Pre|safeHTML}}{{.Name}}{{.Post|safeHTML-}}\u003c/a\u003e{{-end-}} 将上述代码改为如下代码： {{-range.Site.Menus.main-}}{{if.HasChildren}}\u003cdivclass=\"dropdown\"\u003e\u003ca{{if.URL}}href=\"{{ .URL }}\"{{else}}href=\"javascript:void(0);\"{{end}}class=\"menu-item menu-more dropbtn\"title=\"{{ .Title }}\"{{ifeq.Post\"_blank\"}}target=\"_blank\"rel=\"noopener\"{{end}}\u003e{{-.Pre|safeHTML}}{{.Name}}{{ifne.Post\"_blank\"}}{{.Post|safeHTML-}}{{end}}\u003c/a\u003e\u003cdivclass=\"menu-more-content dropdown-content\"\u003e{{-range.Children-}}{{-$url:=.URL|relLangURL-}}{{-with.Page-}}{{-$url=.RelPermalink-}}{{-end-}}\u003cahref=\"{{ $url }}\"title=\"{{ .Title }}\"{{ifeq.Post\"_blank\"}}target=\"_blank\"rel=\"noopener\"{{end}}\u003e{{-.Pre|safeHTML}}{{.Name}}{{ifne.Post\"_blank\"}}{{.Post|safeHTML-}}{{end}}\u003c/a\u003e{{-end-}}\u003c/div\u003e\u003c/div\u003e{{else}}{{-$url:=.URL|relLangURL-}}{{-with.Page-}}{{-$url=.RelPermalink-}}{{-end-}}\u003caclass=\"menu-item{{ if $.IsMenuCurrent `main` . | or ($.HasMenuCurrent `main` .) | or (eq $.RelPermalink $url) }} active{{ end }}\"href=\"{{ $url }}\"{{with.Title}}title=\"{{ . }}\"{{end}}{{if(urls.Parse$url).Host}}rel=\"noopener noreffer\"target=\"_blank\"{{end}}\u003e{{-.Pre|safeHTML}}{{.Name}}{{ifne.Post\"_blank\"}}{{.Post|safeHTML-}}{{end}}\u003c/a\u003e{{-end-}}{{-end-}} ","date":"2022-01-27","objectID":"/hugo_conf2/:9:1","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"添加CSS样式 在_custom.scss中添加如下代码： /* 子菜单栏 */ .dropdown { display: inline-block; } /* 子菜单的内容 (默认隐藏) */ .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2); border-radius: 4px; line-height: 1.3rem; } /* 子菜单的链接 */ .dropdown-content a { padding: 10px 18px 10px 14px; text-decoration: none; display: block; \u0026 i { margin-right: 3px; } } /* 鼠标移上去后修改子菜单链接颜色 */ .dropdown-content a:hover { background-color: #f1f1f1; border-radius: 4px; } /* 在鼠标移上去后显示子菜单 */ .dropdown:hover .dropdown-content { display: block; } @media screen and (max-width: 680px) { .dropdown { display: inline; } .dropdown:hover .dropdown-content { display: inline; z-index: 1; margin-top: -2em; margin-left: 3em; } .dropdown-content a:hover { background-color: transparent; } } ","date":"2022-01-27","objectID":"/hugo_conf2/:9:2","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"配置子菜单 打开站点配置文件config.toml，添加子菜单到菜单栏里。子菜单其实和原本的菜单一样写法，只是多了一个parent属性，用来定位到对应的父菜单的identifier。下面是一个简单的子菜单定义方式（没有使用多语言功能）： # 菜单配置 [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\u003ci class='fas fa-fw fa-archive'\u003e\u003c/i\u003e\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"归档\" url = \"/posts/\" title = \"\" weight = 1 [[menu.main]] pre = \"\u003ci class='fas fa-fw fa-link'\u003e\u003c/i\u003e\" name = \"友链\" identifier = \"friends\" url = \"/friends/\" weight = 2 # 二级菜单 [[menu.main]] parent = \"posts\" pre = \"\u003ci class='fas fa-fw fa-th'\u003e\u003c/i\u003e\" name = \"分类\" identifier = \"categories\" url = \"/categories/\" weight = 1 [[menu.main]] parent = \"posts\" identifier = \"tags\" pre = \"\u003ci class='fas fa-fw fa-tag'\u003e\u003c/i\u003e\" post = \"_blank\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 菜单栏还允许以下配置： 通过给菜单配置一个post = \"_blank\"属性来将该菜单设置为在新窗口打开该链接，如果post属性填其他值则依然作为原本的功能使用：即给name添加后缀。 通过设置title来添加超链的提示文本。 父菜单可以通过将url设置为空来将其渲染为不跳转的超链：url = \"\"。 ","date":"2022-01-27","objectID":"/hugo_conf2/:9:3","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"如何添加自定义的页面 除了发布草稿和正文，我们还可以添加自定义的页面page。page不会像文章那样被渲染，而是被渲染成一个单独的页面，类似于你的文档、标签页面。 如： 在站点根目录的/content/目录下，新建一个文件夹，比如about文件夹。然后在该文件夹里新建一个index.md文件，该文件将作为站点访问该目录的页面，你可以将其当成一篇特殊的文章。 在index.md文件里加上下面的内容，实际上这里只需要title就够了，date这个日期属性可要可不要，因为page页面是看不到这个日期的： --- title: \"关于\" date: 2022-01-27T23:10:00+08:00 --- 接下来你就可以像写普通文章一样，在这个index.md文件里随便写你想要展示的内容就行了。 ","date":"2022-01-27","objectID":"/hugo_conf2/:10:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["Hugo系列"],"content":"背景添加动态线条效果 在layouts/partials/header.html的底部{{- end -}}之前添加如下代码： \u003cscript type=\"text/javascript\" color=\"220,220,220\" opacity='0.7' zIndex=\"-2\" count=\"200\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"\u003e \u003c/script\u003e 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0）；如，41,36,33（象牙黑）。 opacity：表示线条透明度（0~1），默认：0.5。 count：表示线条的总数量，默认：150。 zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1。 ","date":"2022-01-27","objectID":"/hugo_conf2/:11:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强（二）","uri":"/hugo_conf2/"},{"categories":["C/C++语法"],"content":"利用C++的库函数实现O(n)的复杂度就地建堆","date":"2022-01-17","objectID":"/make_heap/","tags":["C/C++"],"title":"C++ 就地建堆的方法","uri":"/make_heap/"},{"categories":["C/C++语法"],"content":"描述 make_heap()用于将序列转换为堆，被定义在**“algorithm”**头文件中。 make_heap的时间复杂度是**O(n)**，低于一个一个插进堆中的O(nlogn)。 标准容器适配器priority_queue自动调用make_heap、push_heap和pop_heap来维护容器的堆属性。 ","date":"2022-01-17","objectID":"/make_heap/:1:0","tags":["C/C++"],"title":"C++ 就地建堆的方法","uri":"/make_heap/"},{"categories":["C/C++语法"],"content":"函数说明 make_heap(iter_first, iter_last, comp)：在容器范围内，就地建堆，保证最大值在所给范围的最前面，其他值的位置不确定。 pop_heap(iter_first, iter_last, comp)：将堆顶（所给范围的最前面）元素移动到所给范围的最后，并且将新的最大值置于所给范围的最前面。 push_heap(iter_first, iter_last, comp)：当已建堆的容器范围内有新的元素插入末尾后，应当调用push_heap将该元素插入堆中。 ","date":"2022-01-17","objectID":"/make_heap/:2:0","tags":["C/C++"],"title":"C++ 就地建堆的方法","uri":"/make_heap/"},{"categories":["C/C++语法"],"content":"参数 first，last：定义要修改的合法非空堆的元素范围。 comp：比较函数对象（即满足比较 (Compare) 要求的对象），若首个参数小于第二个，则返回 true。 比较函数如下： bool cmp(const Type1 \u0026a, const Type2 \u0026b); 注意 函数的首个版本使用operator\u003c比较元素，这使堆成为最大堆。第二版本使用给定的比较函数comp。 ","date":"2022-01-17","objectID":"/make_heap/:3:0","tags":["C/C++"],"title":"C++ 就地建堆的方法","uri":"/make_heap/"},{"categories":["C/C++语法"],"content":"示例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e using namespace std; int main() { //自定义cmp函数 auto cmp = [](const int x, const int y){ return x \u003e y; }; vector\u003cint\u003e nums = {3, 1, 4, 1, 5, 9}; //就地建堆 make_heap(nums.begin(), nums.end(), cmp); cout \u003c\u003c nums.front() \u003c\u003c endl; //移动堆顶 pop_heap(nums.begin(), nums.end(), cmp); nums.pop_back(); //删除堆顶元素 cout \u003c\u003c nums.front() \u003c\u003c endl; //插入新元素 nums.push_back(0); push_heap(nums.begin(), nums.end(), cmp); cout \u003c\u003c nums.front() \u003c\u003c endl; return 0; } 输出： 1 3 0 ","date":"2022-01-17","objectID":"/make_heap/:4:0","tags":["C/C++"],"title":"C++ 就地建堆的方法","uri":"/make_heap/"},{"categories":["Nginx"],"content":"利用nginx来配置域名直接访问云服务器的hugo博客","date":"2022-01-09","objectID":"/nginx_conf/","tags":["Nginx"],"title":"Nginx的安装与配置","uri":"/nginx_conf/"},{"categories":["Nginx"],"content":"前言 ","date":"2022-01-09","objectID":"/nginx_conf/:1:0","tags":["Nginx"],"title":"Nginx的安装与配置","uri":"/nginx_conf/"},{"categories":["Nginx"],"content":"概述 Nginx是开源、高性能、高可靠的Web和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是Nginx最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是，Nginx是免费的并可以商业化，配置使用也比较简单。 ","date":"2022-01-09","objectID":"/nginx_conf/:1:1","tags":["Nginx"],"title":"Nginx的安装与配置","uri":"/nginx_conf/"},{"categories":["Nginx"],"content":"Nginx的特点 作为Web服务器，Nginx处理静态文件、索引文件，自动索引的效率非常高； 作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度； 作为负载均衡服务器，Nginx既可以在内部直接支持 Rails 和 PHP ，也可以支持 HTTP 代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡； 在性能方面，Nginx是专门为性能优化而开发的，实现上非常注重效率。它采用内核 Poll 模型，可以支持更多的并发连接，最大可以支持对5万个并发连接数的响应，而且只占用很低的内存资源； 在稳定性方面，Nginx采取了分阶段资源分配技术，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持1万个没有活动的连接，而这些连接只占用 2.5MB 内存，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的； 在高可用性方面，Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到 7 * 24 小时不间断地运行； 完全开源，生态繁荣。 ","date":"2022-01-09","objectID":"/nginx_conf/:1:2","tags":["Nginx"],"title":"Nginx的安装与配置","uri":"/nginx_conf/"},{"categories":["Nginx"],"content":"Nginx的作用 Nginx的几个重要的使用场景： 静态资源服务，通过本地文件系统提供服务； 反向代理服务，延伸出包括缓存，负载均衡等； API服务，OpenResty。 对于前端来说Node.js并不陌生，Nginx和Node.js的很多理念类似，HTTP 服务器、事件驱动、异步非阻塞等，且Nginx的大部分功能使用Node.js也可以实现，但Nginx和Node.js并不冲突，都有自己擅长的领域。Nginx擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等），Node.js更擅长上层具体业务逻辑的处理，两者可以完美组合。 信息 正向代理与反向代理的区别 正向代理：是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。 反向代理（Reverse Proxy）：是指以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 区别： 位置不同 正向代理，架设在客户机和目标主机之间； 反向代理，架设在服务器端。 代理对象不同 正向代理，代理客户端，服务端不知道实际发起请求的客户端； 反向代理，代理服务端，客户端不知道实际提供服务的服务端。 ","date":"2022-01-09","objectID":"/nginx_conf/:1:3","tags":["Nginx"],"title":"Nginx的安装与配置","uri":"/nginx_conf/"},{"categories":["Nginx"],"content":"Nginx的安装 ","date":"2022-01-09","objectID":"/nginx_conf/:2:0","tags":["Nginx"],"title":"Nginx的安装与配置","uri":"/nginx_conf/"},{"categories":["Nginx"],"content":"安装环境 安装nginx之前，需要安装一些nginx所依赖的环境，下面的环境视自己的系统情况而定。 安装gcc编译环境 sudo apt-get update sudo apt-get install build-essential gcc -v #检验 安装第三方的开发包 PCRE PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。 nginx的 HTTP 模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。 注意 pcre的官网有一个最新的pcre2，安装这个是无法编译nginx的，所以要安装之前版本的pcre。 本文演示的是源码安装方式： 下载源码并解压 wget https://sourceforge.net/projects/pcre/files/pcre/8.45/pcre-8.45.tar.gz tar -zxvf /home/myblog/pcre-8.45.tar.gz -C /home/myblog/pcre #解压目录根据自己的实际情况 编译并安装 cd pcre/pcre-8.45 ./configure make sudo make install zlib zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对 HTTP 包的内容进行gzip，所以需要在linux上安装zlib库。 本文演示的是源码安装方式： 下载源码并解压 wget http://zlib.net/zlib-1.2.11.tar.gz tar -zxvf /home/myblog/zlib-1.2.11.tar.gz -C /home/myblog/zlib #解压目录根据自己的实际情况 编译并安装 cd zlib/zlib-1.2.11 ./configure make sudo make install openssl OpenSSL是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。 nginx不仅支持 HTTP 协议，还支持 HTTPs （即在ssl协议上传输http），所以需要在linux安装openssl库。 本文演示的是源码安装方式： 下载源码并解压 wget http://www.openssl.org/source/openssl-3.0.1.tar.gz tar -zxvf /home/myblog/openssl-3.0.1.tar.gz -C /home/myblog/openssl #解压目录根据自己的实际情况 编译并安装 cd openssl/openssl-3.0.1 ./configure make sudo make install 检验 openssl version 此时会出现报错： openssl: error while loading shared libraries: libssl.so.3: cannot open shared object file: No such file or directory 解决方法： su root或ctrl + d #切换回根用户 ln -s /usr/local/lib64/libssl.so.3 /usr/lib/libssl.so.3 ln -s /usr/local/lib64/libcrypto.so.3 /usr/lib/libcrypto.so.3 注意 第二个路径/usr/lib/要进入自己的/usr看看，是/usr/lib还是/usr/lib64，根据具体的实际情况来。 ","date":"2022-01-09","objectID":"/nginx_conf/:2:1","tags":["Nginx"],"title":"Nginx的安装与配置","uri":"/nginx_conf/"},{"categories":["Nginx"],"content":"安装Nginx 本文演示的是源码安装方式： 下载源码并解压 wget http://nginx.org/download/nginx-1.20.2.tar.gz tar -zxvf /home/myblog/nginx-1.20.2.tar.gz -C /home/myblog/nginx #解压目录根据自己的实际情况 编译并安装 cd nginx/nginx-1.20.2 ./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-openssl=/home/myblog/openssl/openssl-3.0.1 #这里是openssl的源码的位置 make sudo make install 环境变量的配置 此时，nginx已经成功安装，可以用命令whereis nginx查看安装位置，如/usr/local/nginx。我们要使用nginx命令时，必须进入/usr/local/nginx/sbin，为了在任何路径我们都能使用nginx命令来启动nginx，我们可以增加环境变量的配置。 打开文件 sudo vim /etc/profile 在最下面加入如下内容 export PATH=$PATH:/usr/local/nginx/sbin 使配置文件立即生效，之后重启系统 source /etc/profile 验证 nginx -v 输出： nginx version: nginx/1.20.2 注意 用这种wget源码的方式安装，nginx的配置文件在/usr/local/nginx/conf/下； 如果使用apt-get或者yum的方式安装，nginx的配置文件在/etc/nginx/下。 ","date":"2022-01-09","objectID":"/nginx_conf/:2:2","tags":["Nginx"],"title":"Nginx的安装与配置","uri":"/nginx_conf/"},{"categories":["Nginx"],"content":"Nginx的常用命令 cd /usr/local/nginx/sbin/ ./nginx -v #查看nginx的版本 ./nginx #启动 ./nginx -s stop #停止 ./nginx -s quit #安全退出 ./nginx -s reload #重新加载配置文件 ps aux | grep nginx #查看nginx进程 ","date":"2022-01-09","objectID":"/nginx_conf/:2:3","tags":["Nginx"],"title":"Nginx的安装与配置","uri":"/nginx_conf/"},{"categories":["Nginx"],"content":"配置Nginx 前提条件： 已经购买个人域名并完成备案和解析； 已经开启服务器的80端口和443端口； 已经通过阿里云SSL证书服务完成证书签发； 已经下载证书到本地。 ","date":"2022-01-09","objectID":"/nginx_conf/:3:0","tags":["Nginx"],"title":"Nginx的安装与配置","uri":"/nginx_conf/"},{"categories":["Nginx"],"content":"在Nginx服务器上安装证书 在Nginx安装目录（默认为/usr/local/nginx/conf）下创建一个用于存放证书的目录，将其命名为cert： cd /usr/local/nginx/conf #进入Nginx默认安装目录。如果你修改过默认安装目录，请根据实际配置进行调整。 mkdir cert #创建证书目录，命名为cert。 将本地证书文件和私钥文件上传到Nginx服务器的证书目录（示例中为/usr/local/nginx/conf/cert）。 编辑Nginx配置文件（nginx.conf），修改与证书相关的配置内容。 在配置文件中定位到HTTP协议代码片段（http{}），并在HTTP协议代码里面添加以下server配置（如果server配置已存在，按照以下注释内容修改相应配置即可）。 使用示例代码前，请注意替换以下内容： yourdomain.com：替换成证书绑定的域名。 如果你购买的是单域名证书，需要修改为单域名（例如www.aliyundoc.com）；如果你购买的是通配符域名证书，则需要修改为通配符域名（例如*.aliyundoc.com）。 cert-file-name.pem：替换成你在步骤3上传的证书文件的名称。 cert-file-name.key：替换成你在步骤3上传的证书私钥文件的名称。 #以下属性中，以ssl开头的属性表示与证书配置有关。 server { listen 443 ssl; #配置HTTPS的默认访问端口为443。 #如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。 #如果你使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。 server_name yourdomain.com; #需要将yourdomain.com替换成证书绑定的域名。 root html; index index.html index.htm; ssl_certificate cert/cert-file-name.pem; #需要将cert-file-name.pem替换成已上传的证书文件的名称。 ssl_certificate_key cert/cert-file-name.key; #需要将cert-file-name.key替换成已上传的证书私钥文件的名称。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的加密套件的类型。 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示使用的TLS协议的类型。 ssl_prefer_server_ciphers on; location / { root html; #站点目录。如，root /myblog/public。 index index.html index.htm; } } 设置HTTP请求自动跳转HTTPS。 如果你希望所有的HTTP访问自动跳转到HTTPS页面，则可以在需要跳转的HTTP站点下添加以下rewrite语句。 使用示例代码前，请注意将yourdomain.com替换成证书绑定的域名。 server { listen 80; server_name yourdomain.com; #需要将yourdomain.com替换成证书绑定的域名。 rewrite ^(.*)$ https://$host$1; #将所有HTTP请求通过rewrite指令重定向到HTTPS。 location / { index index.html index.htm; } } 执行以下命令，重启Nginx服务。 cd /usr/local/nginx/sbin #进入Nginx服务的可执行目录。 ./nginx -s reload #重新载入配置文件。 如果重启Nginx服务时收到报错，可以使用以下方法进行排查： 收到the \"ssl\" parameter requires ngx_http_ssl_module报错：你需要重新编译Nginx并在编译安装的时候加上--with-http_ssl_module配置。 收到\"/cert/3970497_pic.certificatestests.com.pem\":BIO_new_file() failed (SSL: error:02001002:system library:fopen:No such file or directory:fopen('/cert/3970497_pic.certificatestests.com.pem','r') error:2006D080:BIO routines:BIO_new_file:no such file)报错：你需要去掉证书相对路径最前面的/。例如，你需要去掉/cert/cert-file-name.pem最前面的/，使用正确的相对路径cert/cert-file-name.pem。 ","date":"2022-01-09","objectID":"/nginx_conf/:3:1","tags":["Nginx"],"title":"Nginx的安装与配置","uri":"/nginx_conf/"},{"categories":["C/C++语法"],"content":"C++11的lambda表达式精讲","date":"2021-12-29","objectID":"/lambda/","tags":["C/C++"],"title":"C++的Lambda表达式","uri":"/lambda/"},{"categories":["C/C++语法"],"content":"前言 c++在c++11标准中引入了lambda表达式，一般用于定义匿名函数，使得代码更加灵活简洁。lambda表达式与普通函数类似，也有参数列表、返回值类型和函数体，只是它的定义方式更简洁，并且可以在函数内部定义。 lambda 来源于函数式编程的概念，也是现代编程语言的一个特点。 ","date":"2021-12-29","objectID":"/lambda/:1:0","tags":["C/C++"],"title":"C++的Lambda表达式","uri":"/lambda/"},{"categories":["C/C++语法"],"content":"lambda的优点 声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。 简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。 在需要的时间和地点实现功能闭包，使程序更灵活。 ","date":"2021-12-29","objectID":"/lambda/:1:1","tags":["C/C++"],"title":"C++的Lambda表达式","uri":"/lambda/"},{"categories":["C/C++语法"],"content":"lambda的基本概念 一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。 一个lambda表达式具有如下形式： [capture list](parameter list) -\u003e return type {function body} capture list：捕获列表，是一个lambda所在函数中定义的局部变量的列表，通常为空。 parameter list：参数列表，与普通函数一样。 我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。 auto f = [] {return 27; }; cout \u003c\u003c f() \u003c\u003cendl; #打印27 ","date":"2021-12-29","objectID":"/lambda/:2:0","tags":["C/C++"],"title":"C++的Lambda表达式","uri":"/lambda/"},{"categories":["C/C++语法"],"content":"向lambda传递参数 与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，lambda不能有默认参数。因此，一个lambda调用点实参数目永远与形参数目相等。 如： [](const string\u0026 a, const string\u0026 b){ return a.size() \u003c b.size(); } 空捕获列表表明此lambda不使用它所在函数中的任何局部变量。 可以使用此lambda来调用stable_sort： //按长度排序，长度相同的单词维持字典序 stable_sort(words.begin(), words.end(), [](const string\u0026 a, const string\u0026 b){ return a.size() \u003c b.size(); }); 当stable_sort需要比较两个元素时，它就会调用给定的这个lambda表达式。 ","date":"2021-12-29","objectID":"/lambda/:3:0","tags":["C/C++"],"title":"C++的Lambda表达式","uri":"/lambda/"},{"categories":["C/C++语法"],"content":"使用lambda捕获列表 值捕获：类似参数传递，变量的捕获方式也可以是值或引用。采用值捕获的前提是变量可以拷贝，与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。 引用捕获：如果采用引用方式捕获一个变量，就必须确保被引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在在函数结束后就不复存在了。 隐式捕获：\u0026 告诉编译器采用引用捕获方式，= 则表示采用值捕获方式。 Tips：当我们混合使用隐式捕获和显示捕获时，捕获列表中的第一个元素必须是一个 \u0026 或 = 。此符号指定了默认捕获方式为引用或值。 lambda表达式还可以通过捕获列表捕获一定范围内的变量： []：不捕获任何变量。 [\u0026]：捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。 [=]：捕获外部作用域中所有变量，并作为副本（复制）在函数体中使用（按值捕获）。 [=, \u0026x]：按值捕获外部作用域中所有变量，并按引用捕获x变量。 [\u0026, x]：默认以引用捕获所有变量，但是x是例外，通过复制捕获（按值捕获）。 ：按值捕获x变量，同时不捕获其他变量。 [x…]：以包展开方式复制捕获参数包变量。 [\u0026x]：仅以引用捕获x，其它变量不捕获。 [this]：捕获当前类中的 this 指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 \u0026 或者 =，就默认添加此选项。捕获 this 的目的是可以在lambda中使用当前类的成员函数和成员变量。 [*this]：通过复制方式捕获当前对象。 注意 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。 ","date":"2021-12-29","objectID":"/lambda/:4:0","tags":["C/C++"],"title":"C++的Lambda表达式","uri":"/lambda/"},{"categories":["C/C++语法"],"content":"实例 有一个按单词长度从小到大排列的字符串数组words(vector\u003cstring\u003e words)。 调用 find_if 使用此lambda，我们可以查找第一个长度大于sz的元素： //获取一个迭代器，指向第一个满足size() \u003e= sz的元素 auto f = find_if(words.begin(), words.end(), [sz](const string\u0026 a){ return a.size() \u003e= sz; }); 这里对 find_if 的调用返回一个迭代器，指向第一个长度不小于给定参数sz的元素。如果这样的元素不存在，则返回 words.end()（尾迭代器）的一个拷贝。 for_each 算法 打印 words 中长度大于等于sz的元素。 //打印长度大于等于给定值的单词，每个单词后面接一个空格 for_each(f, words.end(), [](const string\u0026 s){ cout \u003c\u003c s \u003c\u003c \" \"; }); 此lamnda中的捕获列表为空，是因为我们只对lambda所在函数中定义的（非static）变量使用捕获列表。 注意 捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字。 ","date":"2021-12-29","objectID":"/lambda/:5:0","tags":["C/C++"],"title":"C++的Lambda表达式","uri":"/lambda/"},{"categories":["C/C++语法"],"content":"可变lambda 默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个值捕获的变量的值，就必须在参数列表后加上关键字mutable。 int main() { int t = 27; //局部变量 //f可以改变它所捕获的变量的值 auto f = [t]() mutable { return t++; }; cout \u003c\u003c f() \u003c\u003c endl; cout \u003c\u003c f() \u003c\u003c endl; cout \u003c\u003c t \u003c\u003c endl; return 0; } 结果： 28 29 27 一个引用捕获的变量是否可以修改依赖于此引用指向的是一个const类型还是一个非const类型。 ","date":"2021-12-29","objectID":"/lambda/:6:0","tags":["C/C++"],"title":"C++的Lambda表达式","uri":"/lambda/"},{"categories":["C/C++语法"],"content":"指定lambda的返回类型 默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。 auto f = [](int i){ return i \u003c 0 ? -i : i; }; 在本例中，lambda体是单一的return语句，返回一个条件表达式的结果。我们无须指定返回类型，因为可以根据条件运算符的类型推断出来。 //错误：不能判断lambda的返回类型 auto f = [](int i){ if (i \u003c 0) return -i; else return i; }; 编译器推断这个版本的lambda返回类型为void，但它返回了一个int值。 当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型： auto f = [](int i) -\u003e int { if (i \u003c 0) return -i; else return i; }; ","date":"2021-12-29","objectID":"/lambda/:7:0","tags":["C/C++"],"title":"C++的Lambda表达式","uri":"/lambda/"},{"categories":["C/C++语法"],"content":"lambda表达式的类型 lambda表达式的类型在 C++11 中被称为“闭包类型（Closure Type）”。 因此，我们可以认为它是一个带有operator()的类，即仿函数。因此，我们可以使用std::function和std::bind来存储和操作lambda表达式： std::function\u003cint(int)\u003e f1 = [](int a){ return a; }; std::function\u003cint(void)\u003e f2 = std::bind([](int a){ return a; }, 123); 另外，对于没有捕获任何变量的 lambda 表达式，还可以被转换成一个普通的函数指针： using func_t = int(*)(int); func_t f = [](int a){ return a; }; f(123); lambda表达式可以说是就地定义仿函数闭包的**”语法糖“**。它的捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量。而一个使用了成员变量的类的operator()，如果能直接被转换为普通的函数指针，那么lambda表达式本身的 this 指针就丢失掉了。而没有捕获任何外部变量的lambda表达式则不存在这个问题。 这里也可以很自然地解释为何按值捕获无法修改捕获的外部变量。因为按照 C++ 标准，lambda表达式的operator()默认是const的。一个const成员函数是无法修改成员变量的值的。而mutable的作用，就在于取消operator()的const。 需要注意的是，没有捕获变量的 lambda 表达式可以直接转换为函数指针，而捕获变量的 lambda 表达式则不能转换为函数指针： typedef void(*Ptr)(int*); Ptr p = [](int* p){delete p;}; // 正确，没有状态的lambda（没有捕获）的lambda表达式可以直接转换为函数指针 Ptr p1 = [\u0026](int* p){delete p;}; // 错误，有状态的lambda不能直接转换为函数指针 ","date":"2021-12-29","objectID":"/lambda/:8:0","tags":["C/C++"],"title":"C++的Lambda表达式","uri":"/lambda/"},{"categories":["C/C++语法"],"content":"介绍sscanf()和c_str()的简单用法","date":"2021-12-23","objectID":"/sscanfandc_str/","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"sscanf() ","date":"2021-12-23","objectID":"/sscanfandc_str/:1:0","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"描述 从字符串中读取格式化数据。 ","date":"2021-12-23","objectID":"/sscanfandc_str/:1:1","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"函数声明 int sscanf(const char *str, const char *format, ...) 从str读取数据并根据参数格式将它们存储到附加参数给定的位置，就像使用了scanf一样，但从str而不是标准输入(stdin)读取。 ","date":"2021-12-23","objectID":"/sscanfandc_str/:1:2","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"参数 str：C 字符串，是函数检索数据的源。 format：C 字符串，该字符串遵循与scanf中的格式相同的规范。 format说明符形式为[=%[*][width][modifiers]type=]，具体讲解如下： 参数 描述 * 这是一个可选的星号，表示数据是从流stream中读取的，但是可以被忽视，即它不存储在对应的参数中。 width 这指定了在当前读取操作中读取的最大字符数。 modifiers 为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）。 type 一个字符，指定了要被读取的数据类型以及数据读取方式。 ","date":"2021-12-23","objectID":"/sscanfandc_str/:1:3","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"返回值 如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回EOF。 ","date":"2021-12-23","objectID":"/sscanfandc_str/:1:4","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"实例 提取时间 int y, m, d; char str[] = \"2021-12-22\"; sscanf(str, \"%d-%d-%d\", \u0026y, \u0026m, \u0026d); printf(\"%d\\n%d\\n%d\", y,m,d); 结果： y = 2021, m = 12, d = 22; 分割字符串 char sentence[] = \"Zhangsan is 12 years old.\"; char str[20]; int i; sscanf(sentence, \"%s %*s %d\", str, \u0026i); printf(\"%s -\u003e %d\\n\", str, i); 结果： Zhangsan -\u003e 12 ","date":"2021-12-23","objectID":"/sscanfandc_str/:1:5","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"c_str() ","date":"2021-12-23","objectID":"/sscanfandc_str/:2:0","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"描述 c_str()是Borland封装的String类中的一个函数，它返回当前字符串的首字符地址。换种说法，c_str()函数返回一个指向正规C 字符串的指针常量，内容与本string串相同。这是为了与C 语言兼容，在C 语言中没有string类型，故必须通过string类对象的成员函数c_str()把string对象转换成C 中的字符串样式。 ","date":"2021-12-23","objectID":"/sscanfandc_str/:2:1","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"函数声明 const char *c_str() const ","date":"2021-12-23","objectID":"/sscanfandc_str/:2:2","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"参数 该函数不接受任何参数。 ","date":"2021-12-23","objectID":"/sscanfandc_str/:2:3","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"返回值 该函数返回一个指向数组的指针，该数组包含一个以空字符结尾的字符序列（即 C 字符串），表示字符串对象的当前值。 注意 操作c_str()函数的返回值时，只能使用C 字符串的操作函数，如，strcpy()等函数。因为string对象可能在使用后被析构函数释放掉，那么你所指向的内容就具有不确定性。 ","date":"2021-12-23","objectID":"/sscanfandc_str/:2:4","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["C/C++语法"],"content":"实例 示例1 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003cstring\u003e using namespace std; int main() { string str = \"Please divide this sentance into parts\"; char * cstr = new char[str.length() + 1]; strcpy(cstr, str.c_str()); char * p = strtok(cstr, \" \"); while (p != 0) { cout \u003c\u003c p \u003c\u003c '\\n'; p = strtok(NULL, \" \"); } delete[] cstr; return 0; } 输出： Please divide this sentance into parts 示例2 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003cstring\u003e using namespace std; int main() { string s1 = \"Aditya\"; for (int i = 0; i \u003c s1.length(); i ++ ) { cout \u003c\u003c \"The \" \u003c\u003c i + 1 \u003c\u003c \"th character of string \" \u003c\u003c s1 \u003c\u003c \" is \" \u003c\u003c s1.c_str()[i] \u003c\u003c endl; } return 0; } 输出： The 1th character of string Aditya is A The 2th character of string Aditya is d The 3th character of string Aditya is i The 4th character of string Aditya is t The 5th character of string Aditya is y The 6th character of string Aditya is a ","date":"2021-12-23","objectID":"/sscanfandc_str/:2:5","tags":["C/C++"],"title":"巧用sscanf()和c_str()解题","uri":"/sscanfandc_str/"},{"categories":["Hugo系列"],"content":"博客功能增强与美化","date":"2021-12-21","objectID":"/hugo_conf/","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强(一)","uri":"/hugo_conf/"},{"categories":["Hugo系列"],"content":"前言 Hugo本身可以通过修改站点配置文件来完成页面的部分定制，如按钮、多语言等功能。本博客使用的是Hugo的LoveIt主题，本文也是基于该主题而写的，不过Hugo的美化步骤应该大同小异。 ","date":"2021-12-21","objectID":"/hugo_conf/:1:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强(一)","uri":"/hugo_conf/"},{"categories":["Hugo系列"],"content":"配置文件 Hugo默认使用根目录下的config.toml、config.yaml或config.json中的某一个作为站点的配置文件，可以通过--config来配置读取一个或多个配置文件。 hugo --config debugconfig.toml hugo --config a.toml,b.toml,c.toml 除了Hugo 全局配置之外，LoveIt主题还允许您在网站配置中定义以下参数 (这是一个示例config.toml，其内容为默认值)。 config.toml baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息,","date":"2021-12-21","objectID":"/hugo_conf/:2:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强(一)","uri":"/hugo_conf/"},{"categories":["Hugo系列"],"content":"添加自定义的_custom.scss LoveIt主题提供了一个自定义的_custom.scss，可以在该文件里添加自定义的css样式。该文件目录位于\\themes\\LoveIt\\assets\\css\\_custom.scss，不建议直接在该文件里写css代码。 Hugo在渲染页面时优先读取站点根目录下的同名字的目录和文件，所以可以利用这个特点来美化主题。只需要把想修改的主题模板文件拷贝到根目录下同样的目录中并进行修改，这样就可以在不改动原本的主题文件的情况下实现主题美化。 首先在站点根目录下创建一个自定义的文件：\\assets\\css\\_custom.scss，这样Hugo就会最终以该文件来渲染页面的样式。 _custom.scss // ============================== // Custom style // 自定义样式 // ============================== /* Custom styles. */ /* 滚动条 */ ::-webkit-scrollbar { width: 1rem; height: .5rem; } /* 右下角按钮 */ .fixed-button { margin-bottom: 5rem; } /* 图片 */ figcaption { display: none !important; } img[data-sizes=\"auto\"] { display: block; /* width: 50%;*/ } /* 菜单栏 */ #header-desktop .header-wrapper { padding: 0 2rem 0 5vh; } #header-desktop .header-wrapper .menu .menu-item { margin: 0 .3rem; } .menu .menu-item i { margin-right: 2px; } /* 子菜单栏 */ .dropdown { display: inline-block; } /* 子菜单的内容 (默认隐藏) */ .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2); border-radius: 4px; line-height: 1.3rem; } /* 子菜单的链接 */ .dropdown-content a { padding: 10px 18px 10px 14px; text-decoration: none; display: block; \u0026 i { margin-right: 3px; } } /* 鼠标移上去后修改子菜单链接颜色 */ .dropdown-content a:hover { background-color: #f1f1f1; border-radius: 4px; } /* 在鼠标移上去后显示子菜单 */ .dropdown:hover .dropdown-content { display: block; } @media screen and (max-width: 680px) { .dropdown { display: inline; } .dropdown:hover .dropdown-content { display: inline; z-index: 1; margin-top: -2em; margin-left: 3em; } .dropdown-content a:hover { background-color: transparent; } } /* Github Corner */ .github-corner:hover .octo-arm { animation: octocat-wave 560ms ease-in-out } @keyframes octocat-wave { 0%,100% { transform: rotate(0) } 20%,60% { transform: rotate(-25deg) } 40%,80% { transform: rotate(10deg) } } @media (max-width:500px) { .github-corner:hover .octo-arm { animation: none } .github-corner .octo-arm { animation: octocat-wave 560ms ease-in-out } } /* 头像旋转 */ .home .home-profile .home-avatar img { width: 5rem; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ease-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; \u0026:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } } /* Z 轴旋转动画 */ @-webkit-keyframes play { 0% { -webkit-transform: rotateZ(0deg); } 100% { -webkit-transform: rotateZ(-360deg); } } @-moz-keyframes play { 0% { -moz-transform: rotateZ(0deg); } 100% { -moz-transform: rotateZ(-360deg); } } @keyframes play { 0% { transform: rotateZ(0deg); } 100% { transform: rotateZ(-360deg); } } /* 首页头部 */ .home[posts] .home-profile { padding-top: 0; } .home-avatar { padding-top: 2rem !important; } .home-profile { margin-left: -1rem; margin-right: -1rem; background: white; opacity: .85; } [theme=dark] .home-profile { background: #3a3535; opacity: .8; } .home .home-profile .home-title { margin-top: .67em; } /* 首页文章摘要 */ .home[posts] .summary { margin-bottom: .1rem; margin-left: -1rem; margin-right: -1rem; padding-left: 1rem; padding-right: 1rem; background: white; opacity: .95; } [theme=dark] .home[posts] .summary { background: #3a3535; } /* 首页的分页页码 */ .pagination { margin-top: .1rem; margin-bottom: 0; margin-left: -1rem; margin-right: 1rem; padding: 1rem 2rem .5rem 0; background: white; opacity: .95; } [theme=dark] .pagination { background: #3a3535; } /* 首页的阅读全文按钮 */ .single.summary .post-footer a:first-child { position: relative; z-index: 1; \u0026::before { content: ''; position: absolute; z-index: -1; top: 0; bottom: 0; left: -0.25em; right: -0.25em; background-color: hsla(341, 97%, 59%, 0.75); transform-origin: center right; transform: scaleX(0); transition: transform 0.2s ease-in-out; } \u0026:h","date":"2021-12-21","objectID":"/hugo_conf/:3:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强(一)","uri":"/hugo_conf/"},{"categories":["Hugo系列"],"content":"注意 只有使用的是扩展版本的Hugo，才能令_custom.scss文件生效！！！ 请查看你所使用的Hugo版本，如果不是hugo_extended版本，请前往Hugo Release页面下载你当前版本Hugo所对应的hugo_extended版本。 ","date":"2021-12-21","objectID":"/hugo_conf/:3:1","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强(一)","uri":"/hugo_conf/"},{"categories":["Hugo系列"],"content":"添加自定义的custom.js LoveIt主题并没有提供一个文件来让我们自定义JavaScript，所以需要自己创建一个js文件来自定义JavaScript。 首先在站点根目录下创建一个自定义的JavaScript文件：\\static\\js\\custom.js。这个文件需要在body的闭合标签之前引入，并且要在theme.min.js的引入顺序之后。这样可以防止样式被其他文件覆盖，并且不会因为JavaScript文件假装太久导致页面长时间的空白。 对于LoveIt主题，custom.js添加在\\themes\\LoveIt\\layouts\\partials\\assets.html里。 首先把该文件拷贝到根目录下的\\layouts\\partials\\assets.html，然后打开拷贝后的文件，把自定义的JavaScript文件添加到最末尾的{{- partial \"plugin/analytics.html\" . -}}的上一行： {{- /* 自定义的js文件 */ -}} \u003cscript type=\"text/javascript\" src=\"/js/custom.js\"\u003e\u003c/script\u003e 如果有其他的JavaScript文件要引入，加在一样的地方就可以，但是要放在自定义的custom.js之前。 custom.js /* 返回随机颜色 */ function randomColor() { return \"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"; } /* 鼠标点击文字特效 */ var a_idx = 0; var a_click = 1; var a = new Array(\"道可道\", \"非常道\", \"名可名\", \"非常名\", \"虚其心\", \"实其腹\", \"和其光\" ,\"同其尘\", \"居善地\", \"心善渊\", \"少则得\", \"敝则新\", \"上善若水\", \"知人者智\", \"自知者明\", \"道生一\", \"一生二\", \"二生三\", \"三生万物\", \"人法地\", \"地法天\", \"天法道\", \"道法自然\", \"大直若曲\", \"大巧若拙\", \"大辩若讷\", \"合抱之木\", \"生于毫末\", \"九层之台\", \"起于累土\", \"千里之行\", \"始于足下\", \"无为\", \"无我\", \"无欲\", \"居下\", \"清虚\", \"自然\", \"万物之始\", \"大道至简\", \"衍化至繁\", \"澹兮其若海\", \"旷兮其若谷\", \"致虚极\", \"守静笃\", \"善行无辙迹\", \"知其白\", \"守其黑\", \"知其荣\", \"守其辱\", \"道常无为而无不为\", \"上德无为而无以为\", \"万物得一以生\", \"清静为天下正\", \"圣人不病\", \"以其病病\", \"夫惟病病\", \"是以不病\", \"一曰慈\", \"二曰俭\", \"三曰不敢为天下先\", \"勇于敢则杀\"); jQuery(document).ready(function($) { $(\"body\").click(function(e) { /* 点击频率，点击几次就换文字 */ var frequency = 2; if (a_click % frequency === 0) { var $i = $(\"\u003cspan/\u003e\").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ \"z-index\": 9999, \"top\": y - 20, \"left\": x, \"position\": \"absolute\", \"font-weight\": \"bold\", \"color\": randomColor(), \"-webkit-user-select\": \"none\", \"-moz-user-select\": \"none\", \"-ms-user-select\": \"none\", \"user-select\": \"none\" }); $(\"body\").append($i); $i.animate({ \"top\": y - 180, \"opacity\": 0 }, 1500, function() { $i.remove(); }); } a_click ++; }); }); /* 评论框加载背景图片 */ $(\".v[data-class=v] .veditor\").attr('style', \"background-image: url(\" + $cdnPrefix + \"/images/common/valinebg.webp) !important;\"); }); function getCurrentDateString() { var now = new Date(); var month = now.getMonth() + 1; var day = now.getDate(); var hour = now.getHours(); return \"\" + now.getFullYear() + (month \u003c 10 ? \"0\" + month : month) + (day \u003c 10 ? \"0\" + day : day) + (hour \u003c 10 ? \"0\" + hour : hour); } /* 站点运行时间 */ function runtime() { window.setTimeout(\"runtime()\", 1000); /* 请修改这里的起始时间 */ let startTime = new Date('12/10/2021 21:00:00'); let endTime = new Date(); let usedTime = endTime - startTime; let days = Math.floor(usedTime / (24 * 3600 * 1000)); let leavel = usedTime % (24 * 3600 * 1000); let hours = Math.floor(leavel / (3600 * 1000)); let leavel2 = leavel % (3600 * 1000); let minutes = Math.floor(leavel2 / (60 * 1000)); let leavel3 = leavel2 % (60 * 1000); let seconds = Math.floor(leavel3 / (1000)); let runbox = document.getElementById('run-time'); runbox.innerHTML = '本站已运行\u003ci class=\"far fa-clock fa-fw\"\u003e\u003c/i\u003e ' + ((days \u003c 10) ? '0' : '') + days + ' 天 ' + ((hours \u003c 10) ? '0' : '') + hours + ' 时 ' + ((minutes \u003c 10) ? '0' : '') + minutes + ' 分 ' + ((seconds \u003c 10) ? '0' : '') + seconds + ' 秒 '; } runtime(); ","date":"2021-12-21","objectID":"/hugo_conf/:4:0","tags":["Hugo"],"title":"Hugo的文件配置和博客功能增强(一)","uri":"/hugo_conf/"},{"categories":["Hugo系列"],"content":"一些Hugo搭建过程遇到的问题以及解决方法","date":"2021-12-20","objectID":"/hugo_error/","tags":["Hugo"],"title":"Hugo搭建过程的踩坑记录","uri":"/hugo_error/"},{"categories":["Hugo系列"],"content":"前言 本文主要记录在整个站点搭建过程遇到的一些bug以及相应的解决方案。希望能给朋友们一些参考。 云服务器系统 ubuntu 20.04LTS docker版本 docker 20.10.11 hugo版本 hugo v0.90.1-48907889+extended linux/amd64 BuildDate=2021-12-10T10:56:41Z VendorInfo=gohugoio 主题 LoveIt ","date":"2021-12-20","objectID":"/hugo_error/:1:0","tags":["Hugo"],"title":"Hugo搭建过程的踩坑记录","uri":"/hugo_error/"},{"categories":["Hugo系列"],"content":"添加国内软件源 在安装软件的过程中，个别的地区会出现下载速度缓慢的问题，这个时候就需要添加国内的软件源，如清华源，在/etc/apt/sources.list文件中的内容替换为下面的内容。 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse 添加源以后，需要执行sudo apt-get update，此时可能会出现错误。 解决办法： sudo gpg --keyserver keyserver.ubuntu.com --recv 3B4FE6ACC0B21F32 （公钥） sudo gpg --export --armor 3B4FE6ACC0B21F32 | sudo apt-key add - 注意：公钥根据错误提示信息来填写。 ","date":"2021-12-20","objectID":"/hugo_error/:2:0","tags":["Hugo"],"title":"Hugo搭建过程的踩坑记录","uri":"/hugo_error/"},{"categories":["Hugo系列"],"content":"git clone主题报错 报错情况： error: RPC failed; curl 56 GnuTLS recv error (-110): The TLS connection was non-properly terminated. 解决方法： 使用下面命令安装 build-essential、fakeroot 和 dpkg-dev。 sudo apt-get install build-essential fakeroot dpkg-dev 使用下面命令在家目录中创建一个名为 git-rectify 的目录。 mkdir ~/git-rectify 进入 get-rectify 目录并获取 git 源文件。 cd ~/git-rectify apt-get source git 安装所有 git 依赖项。 sudo apt-get build-dep git 安装 libcurl的依赖文件。 sudo apt-get install libcurl4-openssl-dev 进入git目录。 cd git-2.25.1/ 路径名后面2.*是版本号，需要看一下自己的版本。 修改文件内容，需要修改两个文件。 vim ./debian/control # 把libcurl4-gnutls-dev 修改为 libcurl4-openssl-dev vim ./debian/rules # 把TEST =test整行删除 编译和构建安装包。 sudo dpkg-buildpackage -rfakeroot -b 退回上一级目录，安装编译好的安装包。 cd .. sudo dpkg -i git_2.25.1-1ubuntu3.2_amd64.deb 用git进行clone时提示“服务器验证失败”，在命令行下输入： export GIT_SSL_NO_VERIFY=1 ","date":"2021-12-20","objectID":"/hugo_error/:3:0","tags":["Hugo"],"title":"Hugo搭建过程的踩坑记录","uri":"/hugo_error/"},{"categories":["Hugo系列"],"content":"部署到GitHub Pages不显示页面 解决方法： 在github进入仓库，选择Settings，找到Pages。 选择Change theme。 点击Link to another page，再随便选一个主题即可。 ","date":"2021-12-20","objectID":"/hugo_error/:4:0","tags":["Hugo"],"title":"Hugo搭建过程的踩坑记录","uri":"/hugo_error/"},{"categories":["Hugo系列"],"content":"利用Hugo在云服务器上搭建个人博客站点","date":"2021-12-20","objectID":"/hugo_setup/","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"Hugo简介 ","date":"2021-12-20","objectID":"/hugo_setup/:1:0","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"前言 Hugo 是一个基于 Go 语言开发的静态网站生成器（SSG），目前由 @bep 领衔开发，Hugo 的突出特点是简洁、灵活、高效，目前有很多知名网站都在使用 Hugo：Netlify、Let’s Encrypt、IPFS、Cloudflare Developers、DigitalOcean Docs、1Password 等等。与目前国内流行的 Hexo 相比，Hugo 的速度可称为飞速——在安装和使用上都是如此。下面是官网的原话： The world’s fastest framework for building websites Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. ","date":"2021-12-20","objectID":"/hugo_setup/:1:1","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"目录结构 ├── archetypes/ # 文章模板 scaffolds/ ├── assets/ # Hugo 管道 ├── config.toml # 配置文件 _config.yml ├── content/ # 文章目录 source/_posts/ ├── data/ # Hugo 数据文件 source/_data/ ├── layouts/ # 布局模板 ├── public/ # 生成的静态文件 public/ ├── resources/ # Hugo 缓存 ├── static/ # 网站的静态文件 source/ └── themes/ # 主题目录 themes/ 其中，assets、data、layouts、static的作用都是与站点目录下的相应文件夹相同的，且站点目录下的文件可以覆盖主题目录下的相应文件——这意味着你可以在不修改主题文件的前提下方便地定制主题。在 Hugo 中，如果你想要定制主题，你只需在站点目录下新建相应的文件即可。这是非常利于主题的维护的，你只需使用 Git 的submodule的方式安装 Hugo 的主题，然后更新时只需直接在站点根目录下敲一条命令回车即可，非常方便！ 此外，上面的i18n文件夹相当于 Hexo 的主题中的languages文件夹，如果你不喜欢主题的一些文字翻译，可以在站点目录下新建相应文件自定义。这里特别需要提醒的是，Hugo 中的data和i18n文件夹下的所有文件都是可以按「键」覆盖的，即你无需复制文件全文，只需添加你想自定义的那项即可。 ","date":"2021-12-20","objectID":"/hugo_setup/:1:2","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"配置文件 Hugo 中是不区分站点和主题的配置文件的，Hugo 中只有一个位于站点根目录下的config.toml配置文件。你可能注意到.toml后缀，没错，Hugo 默认使用的配置文件是TOML格式的，它的语法是非常简单易懂的，它在语法上也没有缩进的要求。当然，在 Hugo 中你也可使用 Hexo 默认的 YAML 格式。此外，如果你想将文章中的 Front Matter 也从 YAML 转换成 TOML 的话，推荐一个 Python 脚本，但特别注意：尝试前务必先备份！ ","date":"2021-12-20","objectID":"/hugo_setup/:1:3","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"分类方式和组织方式 在 Hugo 中你是无法将文章的 Front Matter 中的categories用于文章的 URL 的。为什么呢？因为 Hugo 中的categories与tags在功能上其实是完全相同的，它们的作用都是将不同的文章联系起来。其实，Front Matter 中的categories和tags在 Hugo 中都属于 Taxonomies： Hugo includes support for user-defined taxonomies to help you demonstrate logical relationships between content for the end users of your website. Hugo 支持用户定义的类别（taxonomies）来帮你为自己网站的读者展示文章之间的逻辑关系。 在 Hugo 中其实你可以自定义自己想要的任何类别，而不仅限于部类（categories）和标签（tags），比如：你可以自定义一个series，也就是系列/专题/专栏。 既然 Hugo 中基于 Front Matter 的部类和标签都属于类别，而类别的作用只是联系文章，部类自然不可能有树状结构，自然也不能用部类来组织文章。那么，在 Hugo 中你要怎么组织文章呢？分区（Sections）。所谓分区，即站点的content目录下的文件夹和子文件夹，一个文件夹即一个分区。很明显，这是基于文件系统的结构的，自然也就支持树状/网状/嵌套结构，也就能够用来实现文章的树状分类。我觉得这是 Hugo 的又一个优点，直接利用起文件系统的结构来组织文章，合理且符合用户预期，Markdown 文档的存放也更有序。 ","date":"2021-12-20","objectID":"/hugo_setup/:1:4","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"docker镜像的拉取和容器的创建 因为Hugo的运行环境需要Go语言，所以这里直接拉取一个docker官方的golang镜像。Hugo默认的调试端口是1313，在云服务器的安全组中将1313端口打开。 拉取镜像 docker pull golang 创建一个容器并进行端口映射 docker run -p 1313:1313 --name myblog_server -itd golang:latest 进入容器 docker attach myblog_server 在容器里创建一个非根用户 adduser xxx 为用户分配sudo权限(没有sudo的话要先安装sudo) usermod -aG sudo xxx 挂起容器（不能ctrl + d，这样会关闭容器） ctrl + p,ctrl + q 配置环境变量：Linux下有两个文件可以配置环境变量，其中/etc/profile是对所有用户生效的；$HOME/.profile是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。 export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 修改/etc/profile后要重启生效，修改$HOME/.profile后使用source命令加载$HOME/.profile文件即可生效。 Tips：在服务器和容器间复制文件，要使用完整的路径。如， docker cp /home/yipxx/hugo-image.png myblog_server:/home/myblog/myblog/static/images ","date":"2021-12-20","objectID":"/hugo_setup/:2:0","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"Hugo的安装 推荐使用 Hugo extended 版本，由于某些主题的一些特性需要将 SCSS 转换为 CSS，推荐使用 Hugo extended 版本来获得更好的使用体验。 wget https://github.com/gohugoio/hugo/releases/download/v0.90.1/hugo_extended_0.90.1_Linux-64bit.tar.gz tar -zxvf hugo_extended_0.90.1_Linux-64bit.tar.gz sudo mv hugo /usr/bin/ 检查是否安装成功 hugo version ","date":"2021-12-20","objectID":"/hugo_setup/:3:0","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"创建Blog站点 首先需要创建一个新的个人站点 hugo new site blog blog就是你的博客站点所在的目录，也是这个站点的根目录，创建站点后目录结构如下： archetypes/ content/ data/ layouts/ static/ themes/ config.toml 下面简单介绍下Hugo根目录下的各个文件目录的作用： archetypes存放创建文件时使用的模板，可以自定义front matter属性。 assets存放需要被Hugo Pipes处理的文件，且只有使用了.Permalink或者.RelPermalink的文件才能被发布到public目录。 注意，默认不会创建assets目录。 config是配置文件，可以有JSON、YAML或者TOML三种格式，默认使用根目录下的config.toml、config.yaml或config.json中的某一个。可以通过--config来配置读取一个或多个配置文件，如：hugo --config a.toml,b.toml,c.toml。注意，默认不会创建config目录。 content存放的各种md文件用于部署站点，该目录下可以自行创建若干个子目录来便于对文章进行分类，这些子目录被称为section。 data目录存放的是用于定义变量的模板文件，相当于Java里的常量类，这些文件有JSON、YAML或者TOML三种格式，会在生成站点时被使用到。一般用不到该功能，具体用法可以参考：data templates。 layouts目录存放的模板文件用于渲染html页面，模板里可以定义不同页面的html代码。 static目录存放的是静态内容：图片、CSS、JavaScript等。 resources目录用于缓存某些文件来提高生成效率。注意，默认不会创建resources目录。 ","date":"2021-12-20","objectID":"/hugo_setup/:4:0","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"添加主题 为新站点添加一个主题，以我使用的LoveIt主题为例。 cd blog git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 然后，修改config.toml： theme = \"LoveIt\" 这里的LoveIt对应themes目录下的主题的文件夹名字。 ","date":"2021-12-20","objectID":"/hugo_setup/:5:0","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"添加文章 新建一篇文章 hugo new posts/my-first-post.md 该命令会在content/posts目录下生成my-first-post.md文件，打开进行编辑： --- title: \"First\" date: 2021-12-12T21:57:28+08:00 draft: true --- ## First Hello World!!! 两行---里的属性是front matter，用来设置当前文章的属性配置。front matter的内容可以使用3种不同的格式来定义，两行---之间对应的是YAML格式，两行+++之间对应的是TOML格式，{和}之间对应的是JSON格式。 draft（草稿）不会被部署；完成帖子后，更新帖子的标题以显示draft：false。 下面是官方文档提供的3种不同格式的front matter的样例，有兴趣的可以了解下。 TOML Example +++ title = \"spf13-vim 3.0 release and new website\" description = \"spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\" tags = [ \".vimrc\", \"plugins\", \"spf13-vim\", \"vim\" ] date = \"2012-04-06\" categories = [ \"Development\", \"VIM\" ] slug = \"spf13-vim-3-0-release-and-new-website\" +++ Content of the file goes Here YAML Example --- title: \"spf13-vim 3.0 release and new website\" description: \"spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\" tags: [ \".vimrc\", \"plugins\", \"spf13-vim\", \"vim\" ] lastmod: 2015-12-23 date: \"2012-04-06\" categories: - \"Development\" - \"VIM\" slug: \"spf13-vim-3-0-release-and-new-website\" --- Content of the file goes Here JSON Example { \"title\": \"spf13-vim 3.0 release and new website\", \"description\": \"spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\", \"tags\": [ \".vimrc\", \"plugins\", \"spf13-vim\", \"vim\" ], \"date\": \"2012-04-06\", \"categories\": [ \"Development\", \"VIM\" ], \"slug\": \"spf13-vim-3-0-release-and-new-website\", } Content of the file goes Here ","date":"2021-12-20","objectID":"/hugo_setup/:6:0","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"启动Hugo服务 利用本地的浏览器访问云服务器上的个人站点来进行调试。 hugo server --bind \"0.0.0.0\" -b \"http://ip:1313\" 开启评论系统,CDN和fingerprint hugo server --bind \"0.0.0.0\" -b \"http://ip:1313\" -e production 该命令仅用于本地调试，支持热修改，也就是说在启动服务时修改文章会实时生效，但是该命令不会真正生成静态文件。 此时，已经直接可以通过http://ip:1313来访问该站点。 ","date":"2021-12-20","objectID":"/hugo_setup/:7:0","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"生成静态页面 输入命令： hugo -D 默认会在站点根目录的public/目录下生成对应的静态页面，可以通过在命令行指定-d或者--destination参数来改变静态页面的存放路径，也可以通过在配置文件中设置publishDir来指定。 该命令生成的静态页面文件是用来部署到pages服务的，比如GitHub pages或者Coding pages等。 另外，hugo允许对生成的静态页面设置特殊的参数，比如在文章的front matter里设置参数：draft,publishdate和expirydate。如下： --- title: \"First\" date: 2020-09-08T21:57:28+08:00 draft: true publishdate: 2020-09-18T21:57:28+08:00 expirydate: 2020-09-28T21:57:28+08:00 --- draft: true表明该文章是草稿，如果在启用服务时不指定参数-D或--buildDrafts，或者在配置文件config.toml中配置buildDrafts = true，则会在生成文章时忽略草稿。如果不想指定该参数就生成文章，需要改为draft: false或者将其删去。 publishdate: 2020-09-18T21:57:28+08:00表示将来发布的时间，如果不指定参数-F或--buildFuture，或者在配置文件config.toml中配置buildFuture = true，则无法在规定的日期之前生成该文章。 expirydate: 2020-09-28T21:57:28+08:00表示过期时间，如果不指定参数-E或--buildExpired，或者在配置文件config.toml中配置buildExpired = true，则无法在规定的日期之后生成该文章。 ","date":"2021-12-20","objectID":"/hugo_setup/:8:0","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"远程部署到Github Pages服务 Hugo和Hexo一样是静态站点生成工具，不需要服务器即可进行部署运行，为了可以在网络上也访问到我们的博客，需要将静态博客部署到某些网站的pages服务上，借用人家的服务器进行托管。 ","date":"2021-12-20","objectID":"/hugo_setup/:9:0","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"在github上创建一个仓库 首先在GitHub上创建一个仓库，仓库的名字格式为\u003cusername\u003e.github.io。 之所以这样规定命名，是因为GitHub默认会把\u003cusername\u003e.github.io的master分支的内容部署到GitHub Pages站点上。 ","date":"2021-12-20","objectID":"/hugo_setup/:9:1","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"SSH key的创建与配置 创建密钥 ssh-keygen 执行结束后，~/.ssh/目录下会多两个文件： id_rsa：私钥 id_rsa.pub：公钥 然后将公钥配置到GitHub账号上。 ","date":"2021-12-20","objectID":"/hugo_setup/:9:2","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["Hugo系列"],"content":"在本地关联GitHub的站点仓库 进入public cd public 创建git项目 git init git全局设置 git config --global user.name \"xxx\" git config --global user.email \"xxx@xxx.com\" 将当前文件上传 git add . 将当前文件提价 git commit -m \"my first post\" 推送现有的git仓库 git remote add origin https://github.com/xxx/\u003cusername\u003e.github.io.git 推送到github git branch -M master git push -u origin master ","date":"2021-12-20","objectID":"/hugo_setup/:9:3","tags":["Hugo"],"title":"Hugo-在云服务上利用docker搭建博客与远程部署","uri":"/hugo_setup/"},{"categories":["文档"],"content":"简单介绍一些Markdown常用的扩展语法","date":"2021-12-12","objectID":"/markdown_expand/","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"LaTeX数学公式 公式一律使用另取一行，并且上下都空一行。 ","date":"2021-12-12","objectID":"/markdown_expand/:1:0","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"行内公式排版 $ c = \\sqrt{a^{2}+b_{0}^{2}+e^{x}} $ $ c = \\sqrt{a^{2}+b_{0}^{2}+e^{x}} $ ","date":"2021-12-12","objectID":"/markdown_expand/:1:1","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"块公式排版 $$ \\begin{aligned} y = y(x,t) \u0026= A e^{i\\theta} \\\\ \u0026= A (\\cos \\theta + i \\sin \\theta) \\\\ \u0026= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\ \u0026= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\ \u0026= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\ \u0026= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t) \\end{aligned} $$ $$ \\begin{aligned} y = y(x,t) \u0026= A e^{i\\theta} \\\\\\\\ \u0026= A (\\cos \\theta + i \\sin \\theta) \\\\\\\\ \u0026= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\\\\\ \u0026= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\\\\\ \u0026= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\\\\\ \u0026= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t) \\end{aligned} $$ ","date":"2021-12-12","objectID":"/markdown_expand/:1:2","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"常用转义 \\boxed或者\\fbox：给公式加一个方框。 \\mathbf：将字体加粗。 \\boldsymbol：将字体斜体且加粗。 \\dfrac：把字号设置为独立公式中的大小。 \\tfrac：把字号设置为行间公式中的大小。 组合数用法与分数类似，在命令前加d和t也能达到分数字号设置同样的功能。 ","date":"2021-12-12","objectID":"/markdown_expand/:1:3","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"格式 上下标 x元素的上标通过^符号后接的内容体现，下表通过_符号后接的内容体现，多于一位是要加{}包裹的。如，$x_{m}^{n}$。 语法 $x_{m}^{n}$ 分式 $\\frac{1}{2}$ 语法 $\\frac{分子}{分母}$ 根式 []中代表是几次根式，{}代表根号下的表达式。如，$\\sqrt[3]{2}$ $\\sqrt[3]{2}$ 求和积分 求和函数表达式 $\\sum_{k=1}^{n}\\frac{1}{k}$ 语法 $\\sum_{k=1}^{n}\\frac{1}{k}$ 积分函数表达式 $\\int_a^bf(x)dx$ 语法 $\\int_a^bf(x)dx$ 空格 紧贴$a!b$ 语法 $a\\!b$ 没有空格$ab$ 语法 $ab$ 小空格$a,b$ 语法 $a\\,b$ 中等空格$a;b$ 语法 $a\\;b$ 大空格$a\\ b$ 语法 $a\\ b$ quad空格$a\\quad b$ 语法 $a\\quad b$ 两个quad空格$a\\qquad b$ 语法 $a\\qquad b$ 公式界定符 通过\\left和\\right后面跟界定符来对同时进行界定。 $\\left(\\sum_{k=\\frac{1}{2}}^{N^2}\\frac{1}{k}\\right)$ 语法 $\\left(\\sum_{k=\\frac{1}{2}}^{N^2}\\frac{1}{k}\\right)$ 多行 \\\\\\\\用来换行，\u0026=用来对齐等号,\\begin{aligned}...\\end{aligned}用来写多行。 $\\begin{aligned} x = a + b \\\\ y = c + d \\\\ z = e + f \\end{aligned}$ 语法 $\\begin{aligned} x = a + b \\\\\\\\ y = c + d \\\\\\\\ z = e + f \\end{aligned}$ ","date":"2021-12-12","objectID":"/markdown_expand/:1:4","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"流程图 语法 {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} ","date":"2021-12-12","objectID":"/markdown_expand/:2:0","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"UML时序图 语法 {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} ","date":"2021-12-12","objectID":"/markdown_expand/:3:0","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"甘特图 语法 {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} ","date":"2021-12-12","objectID":"/markdown_expand/:4:0","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"类图 语法 {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} ","date":"2021-12-12","objectID":"/markdown_expand/:5:0","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"状态图 语法 {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} ","date":"2021-12-12","objectID":"/markdown_expand/:6:0","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"Git 图 语法 {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} ","date":"2021-12-12","objectID":"/markdown_expand/:7:0","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"饼图 语法 {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} ","date":"2021-12-12","objectID":"/markdown_expand/:8:0","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"特殊字符 常见的一些特殊字符。 特殊字符 描述 字符的语法 空格符 \u0026nbsp; \u003c 小于 \u0026lt; \u003e 大于 \u0026gt; \u0026 与 \u0026amp; ¥ 人民币 \u0026yen; © 版权 \u0026copy; ® 注册商标 \u0026reg; °C 摄氏度 \u0026deg;C ± 正负 \u0026plusmn; × 乘 \u0026times; ÷ 除 \u0026divide; ² 平方 \u0026sup2; ³ 立方 \u0026sup3; ","date":"2021-12-12","objectID":"/markdown_expand/:9:0","tags":["Markdown"],"title":"Markdown常用扩展语法","uri":"/markdown_expand/"},{"categories":["文档"],"content":"简单介绍一些Markdown常用的基本语法","date":"2021-12-11","objectID":"/markdown_basic/","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":["文档"],"content":"1. 标题 语法 # 标题1 ## 标题2 ### 标题3 #### 标题4 ##### 标题5 ###### 标题6，最多到标题6 ","date":"2021-12-11","objectID":"/markdown_basic/:1:0","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":["文档"],"content":"2. 字体 斜体 粗体 删除线 斜体加粗体 ~缩小~ ==高亮== 下划线 语法 *斜体* **粗体** ~~删除线~~ ***斜体加粗体*** ~缩小~ ==高亮== \u003cu\u003e下划线\u003c/u\u003e ","date":"2021-12-11","objectID":"/markdown_basic/:2:0","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":["文档"],"content":"3. 引用 引用 引用嵌套 语法 \u003e 引用 \u003e\u003e 引用嵌套 ","date":"2021-12-11","objectID":"/markdown_basic/:3:0","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":["文档"],"content":"4. 分割线 语法 ------- ******* --- *** ","date":"2021-12-11","objectID":"/markdown_basic/:4:0","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":["文档"],"content":"5. 列表 ","date":"2021-12-11","objectID":"/markdown_basic/:5:0","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":["文档"],"content":"有序列表 快速排序 归并排序 冒泡排序 语法 1. 快速排序 2. 归并排序 3. 冒泡排序 ","date":"2021-12-11","objectID":"/markdown_basic/:5:1","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":["文档"],"content":"无序列表 快速排序 归并排序 冒泡排序 语法 */+/- 快速排序 */+/- 归并排序 */+/- 冒泡排序 ","date":"2021-12-11","objectID":"/markdown_basic/:5:2","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":["文档"],"content":"列表嵌套 语法：在二级嵌套的符号前面加四个空格。 一级列表 二级列表 语法 * 一级列表 *二级列表 ","date":"2021-12-11","objectID":"/markdown_basic/:5:3","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":["文档"],"content":"6. 图片 The Dojocat\" The Dojocat 语法 ![图片名称](图片地址 ''图片title'') 图片名称就是显示在图片下面的文字，相当于对图片内容的解释，可加可不加。 图片title是图片的标题，当鼠标移到图片上时显示的内容，可加可不加。 ","date":"2021-12-11","objectID":"/markdown_basic/:6:0","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":["文档"],"content":"7. 超链接 Hugo 语法 [超链接名](超链接地址 \"超链接title\") title可加可不加 ","date":"2021-12-11","objectID":"/markdown_basic/:7:0","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":["文档"],"content":"8. 表格 表头 表头 表头 单元格 单元格 单元格 语法 | 表头 | 表头 | 表头 | | :----: | :----: | :----: | | 单元格 | 单元格 | 单元格 | 对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 ","date":"2021-12-11","objectID":"/markdown_basic/:8:0","tags":["Markdown"],"title":"Markdown常用基本语法","uri":"/markdown_basic/"},{"categories":null,"content":"  ","date":"0001-01-01","objectID":"/games/tetris/:0:0","tags":null,"title":"俄罗斯方块","uri":"/games/tetris/"},{"categories":null,"content":"   莫听穿林打叶声，何妨吟啸且徐行。 竹杖芒鞋轻胜马，谁怕？ 一蓑烟雨任平生。 料峭春风吹酒醒，微冷，山头斜照却相迎。 回首向来萧瑟处，归去，也无风雨也无晴。 —— 苏轼 《定风波·莫听穿林打叶声》  ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"游戏规则 点击小圆点，围住小猫。 你点击一次，小猫走一次。 直到你把小猫围住（赢），或者小猫走到边界并逃跑（输）。 ","date":"0001-01-01","objectID":"/games/catch-the-cat/:1:0","tags":null,"title":"抓住那只猫!","uri":"/games/catch-the-cat/"},{"categories":null,"content":" ","date":"0001-01-01","objectID":"/column/music/:0:0","tags":null,"title":"音乐","uri":"/column/music/"},{"categories":null,"content":"周杰伦2004无与伦比演唱会 ","date":"0001-01-01","objectID":"/column/music/:1:0","tags":null,"title":"音乐","uri":"/column/music/"},{"categories":null,"content":"波西米亚狂想曲 ","date":"0001-01-01","objectID":"/column/music/:2:0","tags":null,"title":"音乐","uri":"/column/music/"},{"categories":null,"content":"周杰伦2007世界巡回演唱会 ","date":"0001-01-01","objectID":"/column/music/:3:0","tags":null,"title":"音乐","uri":"/column/music/"}]